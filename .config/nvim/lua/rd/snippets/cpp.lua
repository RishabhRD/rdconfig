local ls = require "luasnip"
local api = require "rd.snippets.api"
local make = api.make
local t = api.t
local c = api.ch

ls.add_snippets(
  "cpp",
  make {
    inc = {
      desc = "Include for competitive programming",
      c {
        t {
          "#include <optional>",
          "#include <bitset>",
          "#include <unordered_map>",
          "#include <unordered_set>",
          "#include <map>",
          "#include <set>",
          "#include <queue>",
          "#include <deque>",
          "#include <stack>",
          "#include <cmath>",
          "#include <iostream>",
          "#include <limits>",
          "#include <algorithm>",
          "#include <iterator>",
          "#include <limits>",
          "#include <numeric>",
          "#include <vector>",
          "#include <array>",
          "",
          -- "using namespace std;",
          "using ll = long long;",
          "",
          "",
        },
        t {
          "#include <optional>",
          "#include <bitset>",
          "#include <unordered_map>",
          "#include <unordered_set>",
          "#include <map>",
          "#include <set>",
          "#include <queue>",
          "#include <deque>",
          "#include <stack>",
          "#include <cmath>",
          "#include <iostream>",
          "#include <limits>",
          "#include <algorithm>",
          "#include <iterator>",
          "#include <limits>",
          "#include <numeric>",
          "#include <vector>",
          "#include <array>",
          "",
          "using namespace std;",
          "using ll = long long;",
          "",
          "template <typename T> concept is_container = requires(T a) {",
          "  a.begin();",
          "  a.end();",
          "};",
          "",
          "template <is_container T>requires (!std::same_as<T, std::string>)",
          "std::ostream &operator<<(std::ostream &os, const T &cont) {",
          "  os << '{';",
          "  for (const auto &x : cont) {",
          "    os << x;",
          "    os << ' ';",
          "  }",
          "  os << '}';",
          "  return os;",
          "}",
          "",
          "void printMatrix(const is_container auto &cont) {",
          "  for (const auto &x : cont) {",
          "    cout << x;",
          "    cout << '\\n';",
          "  }",
          "}",
          "",
          "template <typename T, std::size_t... Is>",
          "constexpr std::array<T, sizeof...(Is)>",
          "create_array(T value, std::index_sequence<Is...>) {",
          "  return {{(static_cast<void>(Is), value)...}};",
          "}",
          "",
          "template <std::size_t N, typename T>",
          "constexpr std::array<T, N> create_array(const T &value) {",
          "  return create_array(value, std::make_index_sequence<N>());",
          "}",

          "template <typename T>",
          "constexpr auto accessor(T& t){",
          "  return [&](int i) -> typename T::reference{",
          "    return t.at(i);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "constexpr auto accessor(const T& t){",
          "  return [&](int i){",
          "    return t.at(i);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "constexpr auto const_accessor(T& t){",
          "  return [&](int i){",
          "    return t.at(i);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "constexpr auto matrix_accessor(T& t){",
          "  return [&](int i, int j) -> typename T::value_type::reference{",
          "    return t.at(i).at(j);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "constexpr auto matrix_accessor(const T& t){",
          "  return [&](int i, int j) {",
          "    return t.at(i).at(j);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "constexpr auto const_matrix_accessor(T& t){",
          "  return [&](int i, int j) {",
          "    return t.at(i).at(j);",
          "  };",
          "}",
          "",
          "template <typename T>",
          "using lmt = std::numeric_limits<T>;",
          "",
          "template <typename T, std::size_t N>",
          "constexpr std::size_t array_size(const T (&)[N]) noexcept{",
          "  return N;",
          "}",
          "",
          "",
        },
      },
    },
    main = {
      c {
        t {
          "int main(){",
          "}",
        },
        t {
          "int main(int argc, char** argv){",
          "}",
        },
      },
    },
    dsu = {
      t {
        "class dsu {",
        " private:",
        "  using ll = long long;",
        "  std::vector<ll> parent_;",
        "  std::vector<ll> size_;",
        "",
        " public:",
        "  dsu(ll n) : parent_(n), size_(n, 1) {",
        "    std::iota(std::begin(parent_), std::end(parent_), 0);",
        "  }",
        "",
        "  ll find(ll n) {",
        "    if (parent_[n] == n) return n;",
        "    return parent_[n] = find(parent_[n]);",
        "  }",
        "",
        "  void combine(ll x, ll y) {",
        "    auto const px = find(x);",
        "    auto const py = find(y);",
        "    if (px == py) return;",
        "    if (size_[px] >= size_[py]) {",
        "      size_[px] += size_[py];",
        "      parent_[py] = px;",
        "    } else {",
        "      size_[py] += size_[px];",
        "      parent_[px] = py;",
        "    }",
        "  }",
        "",
        "  auto size(ll n) { return size_[find(n)]; }",
        "};",
      },
    },
    cf = {
      t {
        "#include <algorithm>",
        "#include <array>",
        "#include <bitset>",
        "#include <chrono>",
        "#include <cmath>",
        "#include <deque>",
        "#include <iostream>",
        "#include <iterator>",
        "#include <limits>",
        "#include <map>",
        "#include <numeric>",
        "#include <optional>",
        "#include <queue>",
        "#include <set>",
        "#include <stack>",
        "#include <unordered_map>",
        "#include <unordered_set>",
        "#include <vector>",
        "",
        "struct custom_hash {",
        "  static uint64_t splitmix64(uint64_t x) {",
        "    x += 0x9e3779b97f4a7c15;",
        "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
        "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
        "    return x ^ (x >> 31);",
        "  }",
        "",
        "  size_t operator()(uint64_t x) const {",
        "    static const uint64_t FIXED_RANDOM =",
        "        std::chrono::steady_clock::now().time_since_epoch().count();",
        "    return splitmix64(x + FIXED_RANDOM);",
        "  }",
        "};",
        "",
        "using ll = long long;",
        "constexpr ll mod = 1e9 + 7;",
        "",
        "using safe_set = std::unordered_set<ll, custom_hash>;",
        "",
        "template <typename T> using safe_map = std::unordered_map<ll, T>;",
        "",
        "template <typename T> T read() {",
        "  T t;",
        "  std::cin >> t;",
        "  return t;",
        "}",
        "",
        "template <typename T> std::vector<T> read_vec(int n) {",
        "  std::vector<T> vec(n);",
        "  for (auto &ele : vec)",
        "    std::cin >> ele;",
        "  return vec;",
        "}",
        "",
        "template <typename T> auto read_matrix(int m, int n) {",
        "  std::vector<std::vector<T>> vec(m, std::vector<T>(n));",
        "  for (int i = 0; i < m; ++i) {",
        "    for (int j = 0; j < n; ++j) {",
        "      std::cin >> vec[i][j];",
        "    }",
        "  }",
        "  return vec;",
        "}",
        "",
        "auto solve() {}",
        "",
        "int main() {",
        "  auto t = read<int>();",
        "  while (t--) {",
        "  }",
        "}",
      },
    },
    rng_query = {
      t {
        "template <typename T, typename AssociativeFunc>",
        "auto range_query(std::vector<T> const &nums, AssociativeFunc &&func,",
        "                 T const &init) {",
        "  constexpr static auto const k = 25;",
        "  auto const n = std::size(nums);",
        "  std::vector rng(k + 1, std::vector(n, init));",
        "  rng[0] = nums;",
        "  for (ll i = 1; i <= k; ++i) {",
        "    auto const len = 1 << i;",
        "    auto const prev_len = 1 << (i - 1);",
        "    for (ll j = 0; j + len - 1 < n; ++j) {",
        "      rng[i][j] = func(rng[i - 1][j], rng[i - 1][j + prev_len]);",
        "    }",
        "  }",
        "  return [rng = std::move(rng), func = std::forward<AssociativeFunc>(func),",
        "          init](ll a, ll b) {",
        "    auto const len = (b - a + 1);",
        "    std::bitset<k + 1> bs(len);",
        "    auto res = init;",
        "    auto pos = a;",
        "    for (ll i = 0; i <= k; ++i) {",
        "      if (bs[i]) {",
        "        res = func(res, rng[i][pos]);",
        "        pos += (1 << i);",
        "      }",
        "    }",
        "    return res;",
        "  };",
        "}",
      },
    },
    compute_time = {
      t {

        "template <typename F> auto computeTime(F &&f) {",
        "  using namespace std::chrono;",
        "  auto start = high_resolution_clock::now();",
        "  f();",
        "  auto stop = high_resolution_clock::now();",
        "  return (stop - start).count();",
        "}",
      },
    },
  }
)
