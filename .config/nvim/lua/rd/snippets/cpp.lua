local ls = require "luasnip"
local api = require "rd.snippets.api"
local make = api.make
local t = api.t
local c = api.ch
local files = require "rd.utils.file"

ls.add_snippets(
  "cpp",
  make {
    inc = {
      desc = "Include for competitive programming",
      c {
        t {
          "#include <optional>",
          "#include <bitset>",
          "#include <unordered_map>",
          "#include <unordered_set>",
          "#include <map>",
          "#include <set>",
          "#include <queue>",
          "#include <deque>",
          "#include <stack>",
          "#include <cmath>",
          "#include <iostream>",
          "#include <limits>",
          "#include <algorithm>",
          "#include <iterator>",
          "#include <limits>",
          "#include <numeric>",
          "#include <vector>",
          "#include <array>",
          "",
          -- "using namespace std;",
          "using ll = long long;",
          "",
          "",
        },
      },
    },
    main = {
      c {
        t {
          "int main(){",
          "}",
        },
        t {
          "int main(int argc, char** argv){",
          "}",
        },
      },
    },
    dsu = {
      t {
        "class dsu {",
        " private:",
        "  using ll = long long;",
        "  std::vector<ll> parent_;",
        "  std::vector<ll> size_;",
        "",
        " public:",
        "  dsu(ll n) : parent_(n), size_(n, 1) {",
        "    std::iota(std::begin(parent_), std::end(parent_), 0);",
        "  }",
        "",
        "  ll find(ll n) {",
        "    if (parent_[n] == n) return n;",
        "    return parent_[n] = find(parent_[n]);",
        "  }",
        "",
        "  void combine(ll x, ll y) {",
        "    auto const px = find(x);",
        "    auto const py = find(y);",
        "    if (px == py) return;",
        "    if (size_[px] >= size_[py]) {",
        "      size_[px] += size_[py];",
        "      parent_[py] = px;",
        "    } else {",
        "      size_[py] += size_[px];",
        "      parent_[px] = py;",
        "    }",
        "  }",
        "",
        "  auto size(ll n) { return size_[find(n)]; }",
        "};",
      },
    },
    cf = {
      t(files.lines_from(string.format("%s/lua/rd/snippets/codeforces.cpp", vim.fn.stdpath "config"))),
    },
    rng = {
      t {
        "template <typename T, typename AssociativeFunc>",
        "auto range_query(std::vector<T> const &nums, AssociativeFunc &&func,",
        "                 T const &init) {",
        "  constexpr static auto const k = 25;",
        "  auto const n = std::size(nums);",
        "  std::vector rng(k + 1, std::vector(n, init));",
        "  rng[0] = nums;",
        "  for (ll i = 1; i <= k; ++i) {",
        "    auto const len = 1 << i;",
        "    auto const prev_len = 1 << (i - 1);",
        "    for (ll j = 0; j + len - 1 < n; ++j) {",
        "      rng[i][j] = func(rng[i - 1][j], rng[i - 1][j + prev_len]);",
        "    }",
        "  }",
        "  return [rng = std::move(rng), func = std::forward<AssociativeFunc>(func),",
        "          init](ll a, ll b) {",
        "    auto const len = (b - a + 1);",
        "    std::bitset<k + 1> bs(len);",
        "    auto res = init;",
        "    auto pos = a;",
        "    for (ll i = 0; i <= k; ++i) {",
        "      if (bs[i]) {",
        "        res = func(res, rng[i][pos]);",
        "        pos += (1 << i);",
        "      }",
        "    }",
        "    return res;",
        "  };",
        "}",
      },
    },
    rng_i = {
      t {
        "auto calc_log2(ll n) { return __builtin_clzll(1) - __builtin_clzll(n); }",
        "",
        "template <typename T, typename AssociativeFunc>",
        "auto range_query_idempotent(std::vector<T> const &nums,",
        "                            AssociativeFunc &&func) {",
        "  constexpr static auto const k = 25;",
        "  auto const n = std::size(nums);",
        "  std::vector rng(k + 1, std::vector<T>(n));",
        "  rng[0] = nums;",
        "  for (ll i = 1; i <= k; ++i) {",
        "    auto const len = 1 << i;",
        "    auto const prev_len = 1 << (i - 1);",
        "    for (ll j = 0; j + len - 1 < n; ++j) {",
        "      rng[i][j] = func(rng[i - 1][j], rng[i - 1][j + prev_len]);",
        "    }",
        "  }",
        "  return [rng = std::move(rng),",
        "          func = std::forward<AssociativeFunc>(func)](ll a, ll b) {",
        "    auto const len = (b - a + 1);",
        "    auto const i = calc_log2(len);",
        "    return func(rng[i][a], rng[i][b - (1 << i) + 1]);",
        "  };",
        "}",
      },
    },
    compute_time = {
      t {

        "template <typename F> auto computeTime(F &&f) {",
        "  using namespace std::chrono;",
        "  auto start = high_resolution_clock::now();",
        "  f();",
        "  auto stop = high_resolution_clock::now();",
        "  return (stop - start).count();",
        "}",
      },
    },
    fenwick_tree = {
      t {
        "struct fenwick_tree {",
        "  std::vector<ll> bit;",
        "  ll n;",
        "",
        "  fenwick_tree(ll n) : bit(n), n(n) {}",
        "",
        "  fenwick_tree(std::vector<ll> a) : fenwick_tree(a.size()) {",
        "    for (size_t i = 0; i < a.size(); i++)",
        "      add(i, a[i]);",
        "  }",
        "",
        "  ll sum(ll r) {",
        "    ll ret = 0;",
        "    for (; r >= 0; r = (r & (r + 1)) - 1)",
        "      ret += bit[r];",
        "    return ret;",
        "  }",
        "",
        "  ll sum(ll l, ll r) { return sum(r) - sum(l - 1); }",
        "",
        "  void add(ll idx, ll delta) {",
        "    for (; idx < n; idx = idx | (idx + 1))",
        "      bit[idx] += delta;",
        "  }",
        "};",
      },
    },
    fenwick_tree_2d = {
      t {
        "struct fenwick_tree_2d {",
        "  std::vector<std::vector<ll>> bit;",
        "",
        "  fenwick_tree_2d(std::vector<std::vector<ll>> const &a)",
        "      : bit(a.size(), std::vector<ll>(a[0].size())) {",
        "    auto const m = a.size();",
        "    auto const n = a.size();",
        "    for (ll i = 0; i < m; ++i) {",
        "      for (ll j = 0; j < n; ++j) {",
        "        add(i, j, a[i][j]);",
        "      }",
        "    }",
        "  }",
        "",
        "  ll sum(ll x, ll y) {",
        "    ll ret = 0;",
        "    for (ll i = x; i >= 0; i = (i & (i + 1)) - 1)",
        "      for (ll j = y; j >= 0; j = (j & (j + 1)) - 1)",
        "        ret += bit[i][j];",
        "    return ret;",
        "  }",
        "",
        "  void add(ll x, ll y, char value) {",
        "    auto const m = bit.size();",
        "    auto const n = bit[0].size();",
        "    for (ll i = x; i < m; i = i | (i + 1))",
        "      for (ll j = y; j < n; j = j | (j + 1))",
        "        bit[i][j] += value;",
        "  }",
        "};",
      },
    },
    segment_tree = {
      t {
        "// segment tree {{{",
        "// vim: foldmethod=marker",
        "template <typename T, typename GroupFunc> class segment_tree {",
        "  GroupFunc func;",
        "  ll n;",
        "  std::vector<T> arr;",
        "",
        "public:",
        "  segment_tree(std::vector<T> const &arr, GroupFunc func)",
        "      : func(std::move(func)), n(std::size(arr)), arr(n * 4) {",
        "    build(1, 0, n - 1, arr);",
        "  }",
        "",
        "  T query(ll tl, ll tr) { return query(1, 0, n - 1, tl, tr); }",
        "",
        "  void update(ll i, T const &val) {",
        "    update(i, [val](auto e) { return val; });",
        "  }",
        "",
        "  template <typename F> void update(ll i, F &&f) { update(1, 0, n - 1, i, f); }",
        "",
        "private:",
        "  void build(ll i, ll l, ll r, std::vector<T> const &vec) {",
        "    if (l == r) {",
        "      arr[i] = vec[l];",
        "    } else {",
        "      auto const m = l + ((r - l) / 2);",
        "      build(2 * i, l, m, vec);",
        "      build(2 * i + 1, m + 1, r, vec);",
        "      arr[i] = func(arr[2 * i], arr[2 * i + 1]);",
        "    }",
        "  }",
        "",
        "  T query(ll i, ll l, ll r, ll tl, ll tr) {",
        "    if (l == tl && r == tr)",
        "      return arr[i];",
        "    auto const m = l + ((r - l) / 2);",
        "    if (tl >= l and tr <= m) {",
        "      return query(2 * i, l, m, tl, tr);",
        "    } else if (tl >= (m + 1) and tr <= r) {",
        "      return query(2 * i + 1, m + 1, r, tl, tr);",
        "    } else {",
        "      auto const left = query(2 * i, l, m, tl, m);",
        "      auto const right = query(2 * i + 1, m + 1, r, m + 1, tr);",
        "      return func(left, right);",
        "    }",
        "  }",
        "",
        "  template <typename F> void update(ll i, ll l, ll r, ll idx, F &&f) {",
        "    if (l == r) {",
        "      arr[i] = f(arr[i]);",
        "      return;",
        "    }",
        "    auto const m = l + ((r - l) / 2);",
        "    if (idx <= m) {",
        "      update(2 * i, l, m, idx, f);",
        "    } else {",
        "      update(2 * i + 1, m + 1, r, idx, f);",
        "    }",
        "    arr[i] = func(arr[2 * i], arr[2 * i + 1]);",
        "  }",
        "};",
        "",
        "template <typename T, typename GroupFunc>",
        "segment_tree(std::vector<T> const &, GroupFunc) -> segment_tree<T, GroupFunc>;",
        "// segment tree }}}",
      },
    },
    binary_search = {
      t {
        "template <typename Predicate>",
        "ll binary_search(ll low, ll high, Predicate &&predicate) {",
        "  if (low >= high)",
        "    return low;",
        "  auto const mid = low + (high - low) / 2;",
        "  if (predicate(mid)) {",
        "    return binary_search(mid + 1, high, predicate);",
        "  } else {",
        "    return binary_search(low, mid, predicate);",
        "  }",
        "}",
      },
    },
    power = {
      t {
        "ll power(ll n, ll x) {",
        "  if (x == 0)",
        "    return 1;",
        "  auto ans = power(n, x / 2);",
        "  ans = (ans * ans) % mod;",
        "  if (x % 2)",
        "    ans = (ans * n) % mod;",
        "  return ans;",
        "}",
      },
    },
    mod_power = {
      t {
        "ll mod_power(ll n, ll x, ll mod) {",
        "  if (x == 0)",
        "    return 1;",
        "  auto ans = mod_power(n, x / 2, mod);",
        "  ans = (ans * ans) % mod;",
        "  if (x % 2)",
        "    ans = (ans * n) % mod;",
        "  return ans;",
        "}",
      },
    },
    inv = {
      t {
        "ll inv(ll n, ll mod) { return mod_power(n, mod - 2, mod); }",
      },
    },
    gen_power = {
      t {
        "template <typename T, typename Op> T gen_power(T n, ll x, T unit, Op &&op) {",
        "  if (x == 0)",
        "    return unit;",
        "  auto ans = gen_power(n, x / 2, unit, op);",
        "  ans = op(ans, ans);",
        "  if (x % 2)",
        "    ans = op(n, ans);",
        "  return ans;",
        "}",
      },
    },
    print_matrix = {
      t {
        "void print_matrix(std::vector<std::vector<ll>> const &matrix) {",
        "  for (ll i = 0; i < matrix.size(); ++i) {",
        "    for (ll j = 0; j < matrix[0].size(); ++j) {",
        "      std::cout << matrix[i][j] << ' ';",
        "    }",
        "    std::cout << std::endl;",
        "  }",
        "}",
      },
    },
    mod_op = {
      t {
        "auto make_mod_plus(ll mod) {",
        "  return [mod](ll a, ll b) { return (a + b) % mod; };",
        "}",
        "",
        "auto make_mod_minus(ll mod) {",
        "  return [mod](ll a, ll b) { return (a - b + mod) % mod; };",
        "}",
        "",
        "auto make_mod_multiply(ll mod) {",
        "  return [mod](ll a, ll b) { return (a * b) % mod; };",
        "}",
        "",
        "// TODO: find out why this is more efficient than calling make_mod_plus",
        "auto mod_plus(ll a, ll b) { return (a + b) % mod; }",
        "auto mod_minus(ll a, ll b) { return (a - b + mod) % mod; }",
        "auto mod_multiply(ll a, ll b) { return (a * b) % mod; }",
      },
    },
    matrix_multiply = {
      t {
        "template <typename T = ll, typename BiOp = std::multiplies<>,",
        "          typename FoldOp = std::plus<>>",
        "auto matrix_multiply(std::vector<std::vector<T>> const &a,",
        "                     std::vector<std::vector<T>> const &b, T const &init = 0,",
        "                     BiOp &&biop = std::multiplies<>{},",
        "                     FoldOp &&foldop = std::plus<>{}) {",
        "  auto const n = std::size(a);",
        "  std::vector<std::vector<T>> matrix(n, std::vector<T>(n, init));",
        "  for (ll i = 0; i < n; ++i) {",
        "    for (ll j = 0; j < n; ++j) {",
        "      for (ll k = 0; k < n; ++k) {",
        "        matrix[i][j] = foldop(matrix[i][j], biop(a[i][k], b[k][j]));",
        "      }",
        "    }",
        "  }",
        "  return matrix;",
        "}",
        "",
        "template <typename T = ll, typename BiOp = std::multiplies<>,",
        "          typename FoldOp = std::plus<>>",
        "auto make_matrix_multiply(T init = 0, BiOp &&biop = std::multiplies<>{},",
        "                          FoldOp &&foldop = std::plus<>{}) {",
        "  return [biop, foldop, init](std::vector<std::vector<T>> const &a,",
        "                              std::vector<std::vector<T>> const &b) {",
        "    return matrix_multiply(a, b, init, biop, foldop);",
        "  };",
        "}",
      },
    },
    make_unit_matrix = {
      t {
        "auto make_unit_matrix(ll n) {",
        "  std::vector matrix(n, std::vector(n, 0ll));",
        "  for (ll i = 0; i < n; ++i)",
        "    matrix[i][i] = 1;",
        "  return matrix;",
        "}",
      },
    },
    gen_power_without_0 = {
      t {
        "template <typename T, typename Op> T gen_power_w0(T n, ll x, Op &&op) {",
        "  if (x == 1)",
        "    return n;",
        "  auto ans = gen_power_w0(n, x / 2, op);",
        "  ans = op(ans, ans);",
        "  if (x % 2)",
        "    ans = op(n, ans);",
        "  return ans;",
        "}",
      },
    },
    gcd_with_sign = {
      t {
        "ll gcd_with_sign(ll a, ll b) {",
        "  if (b == 0)",
        "    return a;",
        "  a %= b;",
        "  return gcd(b, a);",
        "}",
      },
    },
    make_prime_factors = {
      t {
        "auto make_prime_factors(ll n) {",
        "  std::vector<std::pair<ll, ll>> prime_factors;",
        "  {",
        "    ll cnt = 0;",
        "    while (n % 2 == 0) {",
        "      ++cnt;",
        "      n = n / 2;",
        "    }",
        "    if (cnt > 0) {",
        "      prime_factors.push_back({2, cnt});",
        "    }",
        "  }",
        "",
        "  for (ll i = 3; i * i <= n; i += 2) {",
        "    ll cnt = 0;",
        "    while (n % i == 0) {",
        "      ++cnt;",
        "      n = n / i;",
        "    }",
        "    if (cnt > 0) {",
        "      prime_factors.push_back({i, cnt});",
        "    }",
        "  }",
        "",
        "  if (n > 2) {",
        "    prime_factors.push_back({n, 1});",
        "  }",
        "",
        "  return prime_factors;",
        "}",
      },
    },
    range_of = {
      t {
        "// range of {{{",
        "",
        "template <typename Iter> struct range_of {",
        "  range_of(Iter begin, Iter end) : _begin(begin), _end(end) {}",
        "  Iter begin() const noexcept { return _begin; }",
        "  Iter end() const noexcept { return _end; }",
        "",
        "private:",
        "  Iter _begin;",
        "  Iter _end;",
        "};",
        "",
        "template <typename Iter> range_of(Iter, Iter) -> range_of<Iter>;",
        "// range of }}}",
        "",
      },
    },
    group_by_17 = {
      t {
        "// group by {{{",

        "template <typename Iter> struct range_of {",
        "  range_of(Iter begin, Iter end) : _begin(begin), _end(end) {}",
        "  Iter begin() const noexcept { return _begin; }",
        "  Iter end() const noexcept { return _end; }",
        "",
        "private:",
        "  Iter _begin;",
        "  Iter _end;",
        "};",
        "",
        "template <typename Iter> range_of(Iter, Iter) -> range_of<Iter>;",
        "",
        "namespace GroupBy {",
        "template <typename Iter, typename F> class group_by_iterator {",
        "public:",
        "  using iterator_category = std::forward_iterator_tag;",
        "  using value_type = range_of<Iter>;",
        "  using difference_type = long long;",
        "",
        "  group_by_iterator(Iter begin, Iter end, F f) : begin(begin), end(end), f(f) {}",
        "",
        "  value_type operator*() const { return {begin, compute_end()}; }",
        "",
        "  group_by_iterator &operator++() {",
        "    begin = compute_end();",
        "    cached_end = std::nullopt;",
        "    return *this;",
        "  }",
        "",
        "  group_by_iterator operator++(int) const {",
        "    auto cur = *this;",
        "    begin = compute_end();",
        "    cached_end = std::nullopt;",
        "    return cur;",
        "  }",
        "",
        "  bool operator==(group_by_iterator const &other) const {",
        "    return begin == other.begin && end == other.end;",
        "  }",
        "",
        "private:",
        "  Iter compute_end() const {",
        "    if (cached_end.has_value())",
        "      return cached_end.value();",
        "    if (begin == end) {",
        "      return end;",
        "    }",
        "    Iter prev = begin;",
        "    Iter cur = std::next(prev);",
        "    while (cur != end) {",
        "      if (f(*prev, *cur)) {",
        "        prev = cur;",
        "        ++cur;",
        "      } else {",
        "        break;",
        "      }",
        "    }",
        "    cached_end = cur;",
        "    return cur;",
        "  }",
        "",
        "  Iter begin;",
        "  Iter end;",
        "  mutable std::optional<Iter> cached_end;",
        "  F f;",
        "};",
        "} // namespace GroupBy",
        "",
        "template <typename Iter, typename F>",
        "auto group_by(Iter begin, Iter end, F &&f) {",
        "  using namespace GroupBy;",
        "  return range_of{group_by_iterator<Iter, F>{begin, end, f},",
        "                  group_by_iterator<Iter, F>{end, end, f}};",
        "}",
        "",
        "template <typename Range, typename F> auto group_by(Range &&rng, F &&f) {",
        "  using namespace GroupBy;",
        "  using Iter = decltype(begin(std::declval<Range>()));",
        "  return std::ranges::subrange(",
        "      group_by_iterator<Iter, F>{begin(rng), end(rng), f},",
        "      group_by_sentinal_t{});",
        "}",
        "// group by }}}",
      },
    },
    group_by = {
      t {
        "// group by {{{",
        "namespace GroupBy {",
        "",
        "template <typename T> class wrapper {",
        "  T val_;",
        "",
        "public:",
        "  wrapper() = default;",
        "  wrapper(T val) : val_(std::move(val)) {}",
        "",
        "  constexpr T const *operator->() const { return std::addressof(val_); }",
        "  constexpr T *operator->() { return std::addressof(val_); }",
        "  constexpr T const &operator*() const { return val_; }",
        "  constexpr T &operator*() { return val_; }",
        "",
        "  constexpr explicit operator bool() const noexcept { return true; }",
        "  constexpr bool has_value() const noexcept { return true; }",
        "};",
        "",
        "template <typename T> class semiregular {",
        "  std::optional<T> val_;",
        "",
        "public:",
        "  semiregular() : val_(std::in_place) {}",
        "",
        "  constexpr semiregular(T t) : val_(std::move(t)) {}",
        "  constexpr semiregular(std::nullopt_t) : val_(std::nullopt) {}",
        "",
        "  constexpr semiregular(semiregular const &) = default;",
        "  constexpr semiregular(semiregular &&) = default;",
        "",
        "  constexpr semiregular &operator=(semiregular const &other) {",
        "    if (this != std::addressof(other)) {",
        "      if (other)",
        "        emplace(*other);",
        "      else",
        "        reset();",
        "    }",
        "    return *this;",
        "  }",
        "",
        "  constexpr semiregular &operator=(semiregular &&other) {",
        "    if (this != std::addressof(other)) {",
        "      if (other)",
        "        emplace(std::move(*other));",
        "      else",
        "        reset();",
        "    }",
        "    return *this;",
        "  }",
        "",
        "  constexpr void reset() { val_.reset(); }",
        "",
        "  constexpr T const *operator->() const { return std::addressof(val_.value()); }",
        "  constexpr T *operator->() { return std::addressof(val_.value()); }",
        "  constexpr T const &operator*() const { return val_.value(); }",
        "  constexpr T &operator*() { return val_.value(); }",
        "",
        "  constexpr explicit operator bool() const noexcept { return val_.has_value(); }",
        "  constexpr bool has_value() const noexcept { return val_.has_value(); }",
        "",
        "  template <typename... Args> constexpr T &emplace(Args &&...args) {",
        "    val_.emplace(std::forward<Args>(args)...);",
        "    return val_.value();",
        "  }",
        "};",
        "",
        "template <typename T>",
        "using semiregular_box_t =",
        "    typename std::conditional<std::semiregular<T>, wrapper<T>,",
        "                              semiregular<T>>::type;",
        "",
        "class group_by_sentinal_t {};",
        "",
        "template <typename Iter, typename F> class group_by_iterator {",
        "public:",
        "  using iterator_category = std::forward_iterator_tag;",
        "  using value_type = std::ranges::subrange<Iter, Iter>;",
        "  using difference_type = long long;",
        "",
        "  group_by_iterator(Iter begin, Iter end, F f) : begin(begin), end(end), f(f) {}",
        "  // TODO: Bug in codeforces, this default initializable not required",
        "  group_by_iterator() : f(std::nullopt) {}",
        "",
        "  value_type operator*() const { return {begin, compute_end()}; }",
        "",
        "  group_by_iterator &operator++() {",
        "    begin = compute_end();",
        "    cached_end = std::nullopt;",
        "    return *this;",
        "  }",
        "",
        "  group_by_iterator operator++(int) const {",
        "    auto cur = *this;",
        "    begin = compute_end();",
        "    cached_end = std::nullopt;",
        "    return cur;",
        "  }",
        "",
        "  bool operator==(group_by_iterator const &other) const {",
        "    return begin == other.begin && end == other.end;",
        "  }",
        "",
        "  bool operator==(group_by_sentinal_t) const { return begin == end; }",
        "",
        "private:",
        "  Iter compute_end() const {",
        "    if (cached_end.has_value())",
        "      return cached_end.value();",
        "    if (begin == end) {",
        "      return end;",
        "    }",
        "    Iter prev = begin;",
        "    Iter cur = std::next(prev);",
        "    while (cur != end) {",
        "      if ((*f)(*prev, *cur)) {",
        "        prev = cur;",
        "        ++cur;",
        "      } else {",
        "        break;",
        "      }",
        "    }",
        "    cached_end = cur;",
        "    return cur;",
        "  }",
        "",
        "  Iter begin;",
        "  Iter end;",
        "  mutable std::optional<Iter> cached_end;",
        "  semiregular_box_t<F> f;",
        "};",
        "} // namespace GroupBy",
        "",
        "template <typename Iter, typename F>",
        "auto group_by(Iter begin, Iter end, F &&f) {",
        "  using namespace GroupBy;",
        "  return std::ranges::subrange{group_by_iterator<Iter, F>{begin, end, f},",
        "                               group_by_sentinal_t{}};",
        "}",
        "",
        "template <typename Range, typename F> auto group_by(Range &&rng, F f) {",
        "  using namespace GroupBy;",
        "  using Iter = decltype(begin(std::declval<Range>()));",
        "  return std::ranges::subrange<group_by_iterator<Iter, F>, group_by_sentinal_t>(",
        "      group_by_iterator<Iter, F>{begin(rng), end(rng), std::move(f)},",
        "      group_by_sentinal_t{});",
        "}",
        "// group by }}}",
      },
    },
    find_euler = {
      t {
        "void find_euler(ll i, std::vector<std::vector<ll>> &graph,",
        "                std::vector<ll> &res) {",
        "  while (graph[i].size()) {",
        "    ll const n = graph[i].back();",
        "    graph[i].pop_back();",
        "    find_euler(n, graph, res);",
        "  }",
        "",
        "  res.push_back(i);",
        "}",
      },
    },
    to = {
      t {
        "// rd::to {{{",
        "namespace rd {",
        "namespace detail {",
        "template <class C, class R>",
        "concept reservable = std::ranges::sized_range<R> && requires(C &c, R &&rng) {",
        "  { c.capacity() } -> std::same_as<std::ranges::range_size_t<C>>;",
        "  { c.reserve(std::ranges::range_size_t<R>(0)) };",
        "};",
        "",
        "template <class C>",
        "concept insertable = requires(C c) { std::inserter(c, std::ranges::end(c)); };",
        "",
        "template <class> constexpr inline bool always_false = false;",
        "",
        "// R is a nested range that can be converted to the nested container C",
        "template <class C, class R>",
        "concept matroshkable =",
        "    std::ranges::input_range<C> && std::ranges::input_range<R> &&",
        "    std::ranges::input_range<std::ranges::range_value_t<C>> &&",
        "    std::ranges::input_range<std::ranges::range_value_t<R>> &&",
        "    !std::ranges::view<std::ranges::range_value_t<C>> &&",
        "    std::indirectly_copyable<",
        "        std::ranges::iterator_t<std::ranges::range_value_t<R>>,",
        "        std::ranges::iterator_t<std::ranges::range_value_t<C>>> &&",
        "    detail::insertable<C>;",
        "",
        "template <std::ranges::input_range R> struct fake_input_iterator {",
        "  using iterator_category = std::input_iterator_tag;",
        "  using value_type = std::ranges::range_value_t<R>;",
        "  using difference_type = std::ranges::range_difference_t<R>;",
        "  using pointer = std::ranges::range_value_t<R> *;",
        "  using reference = std::ranges::range_reference_t<R>;",
        "  reference operator*();",
        "  fake_input_iterator &operator++();",
        "  fake_input_iterator operator++(int);",
        "  fake_input_iterator() = default;",
        "  friend bool operator==(fake_input_iterator a, fake_input_iterator b) {",
        "    return false;",
        "  }",
        "};",
        "",
        "template <template <typename...> typename C, std::ranges::input_range R,",
        "          typename... Args>",
        "struct ctad_container {",
        "  template <class V = R>",
        "  static auto deduce(int)",
        "      -> decltype(C(std::declval<V>(), std::declval<Args>()...));",
        "",
        "  template <class Iter = fake_input_iterator<R>>",
        "  static auto deduce(...)",
        "      -> decltype(C(std::declval<Iter>(), std::declval<Iter>(),",
        "                    std::declval<Args>()...));",
        "",
        "  using type = decltype(deduce(0));",
        "};",
        "} // namespace detail",
        "",
        "template <std::ranges::input_range C, std::ranges::input_range R,",
        "          typename... Args>",
        "  requires(!std::ranges::view<C>)",
        "constexpr C to(R &&r, Args &&...args) {",
        "  // Construct from range",
        "  if constexpr (std::constructible_from<C, R, Args...>) {",
        "    return C(std::forward<R>(r), std::forward<Args>(args)...);",
        "  }",
        "  // Construct and copy (potentially reserving memory)",
        "  else if constexpr (std::constructible_from<C, Args...> &&",
        "                     std::indirectly_copyable<std::ranges::iterator_t<R>,",
        "                                              std::ranges::iterator_t<C>> &&",
        "                     detail::insertable<C>) {",
        "    C c(std::forward<Args>(args)...);",
        "    if constexpr (std::ranges::sized_range<R> && detail::reservable<C, R>) {",
        "      c.reserve(std::ranges::size(r));",
        "    }",
        "    std::ranges::copy(r, std::inserter(c, std::end(c)));",
        "    return c;",
        "  }",
        "  // Nested case",
        "  else if constexpr (detail::matroshkable<C, R>) {",
        "    C c(std::forward<Args...>(args)...);",
        "    if constexpr (std::ranges::sized_range<R> && detail::reservable<C, R>) {",
        "      c.reserve(std::ranges::size(r));",
        "    }",
        "    auto v = r | std::views::transform([](auto &&elem) {",
        "               return rd::to<std::ranges::range_value_t<C>>(elem);",
        "             });",
        "    std::ranges::copy(v, std::inserter(c, std::end(c)));",
        "    return c;",
        "  }",
        "  // Construct from iterators",
        "  else if constexpr (std::constructible_from<C, std::ranges::iterator_t<R>,",
        "                                             std::ranges::sentinel_t<R>,",
        "                                             Args...>) {",
        "    return C(std::ranges::begin(r), std::ranges::end(r),",
        "             std::forward<Args>(args)...);",
        "  } else {",
        '    static_assert(detail::always_false<C>, "C is not constructible from R");',
        "  }",
        "}",
        "",
        "template <",
        "    template <typename...> typename C, std::ranges::input_range R,",
        "    typename... Args,",
        "    class ContainerType = typename detail::ctad_container<C, R, Args...>::type>",
        "constexpr auto to(R &&r, Args &&...args) -> ContainerType {",
        "  return rd::to<ContainerType>(std::forward<R>(r), std::forward<Args>(args)...);",
        "}",
        "",
        "namespace detail {",
        "template <std::ranges::input_range C, class... Args> struct closure_range {",
        "  template <class... A>",
        "  closure_range(A &&...as) : args_(std::forward<A>(as)...) {}",
        "  std::tuple<Args...> args_;",
        "};",
        "",
        "template <std::ranges::input_range R, std::ranges::input_range C, class... Args>",
        "auto constexpr operator|(R &&r, closure_range<C, Args...> &&c) {",
        "  return std::apply(",
        "      [&r](auto &&...inner_args) {",
        "        return rd::to<C>(std::forward<R>(r),",
        "                         std::forward<decltype(inner_args)>(inner_args)...);",
        "      },",
        "      std::move(c.args_));",
        "}",
        "",
        "template <template <class...> class C, class... Args> struct closure_ctad {",
        "  template <class... A>",
        "  closure_ctad(A &&...as) : args_(std::forward<A>(as)...) {}",
        "  std::tuple<Args...> args_;",
        "};",
        "",
        "template <std::ranges::input_range R, template <class...> class C,",
        "          class... Args>",
        "auto constexpr operator|(R &&r, closure_ctad<C, Args...> &&c) {",
        "  return std::apply(",
        "      [&r](auto &&...inner_args) { return rd::to<C>(std::forward<R>(r)); },",
        "      std::move(c.args_));",
        "}",
        "",
        "} // namespace detail",
        "",
        "template <template <typename...> typename C, class... Args>",
        "constexpr auto to(Args &&...args) {",
        "  return detail::closure_ctad<C, Args...>{std::forward<Args>(args)...};",
        "}",
        "",
        "template <std::ranges::input_range C, class... Args>",
        "constexpr auto to(Args &&...args) {",
        "  return detail::closure_range<C, Args...>{std::forward<Args>(args)...};",
        "}",
        "} // namespace rd",
        "// }}}",
      },
    },

    fold = {
      t {
        "// fold {{{",
        "namespace rd {",
        "namespace detail {",
        "struct foldl_t {",
        "  constexpr auto operator()(auto &&rng, auto &&init, auto &&op) const {",
        "    return std::accumulate(",
        "        std::begin(vw::common(rng)), std::end(vw::common(rng)),",
        "        std::forward<decltype(init)>(init), std::forward<decltype(op)>(op));",
        "  }",
        "};",
        "} // namespace detail",
        "constexpr auto foldl = rd::pipeable{detail::foldl_t{}};",
        "",
        "namespace detail {",
        "struct sum_t {",
        "  constexpr auto operator()(auto &&rng) const {",
        "    return foldl(std::forward<decltype(rng)>(rng),",
        "                 rng::range_value_t<decltype(rng)>(0), std::plus<>{});",
        "  }",
        "};",
        "}; // namespace detail",
        "constexpr auto sum = rd::pipeable{detail::sum_t{}};",
        "",
        "} // namespace rd",
        "// }}}",
      },
    },
  }
)
