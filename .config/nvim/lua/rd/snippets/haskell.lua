local ls = require "luasnip"
local api = require "rd.snippets.api"
local make = api.make
local t = api.t
local c = api.ch

ls.add_snippets(
  "haskell",
  make {
    cf = {
      t {
        "-- pragmas.hs  {{{",
        "-- vim: foldmethod=marker",
        "{-# LANGUAGE AllowAmbiguousTypes        #-}",
        "{-# LANGUAGE BinaryLiterals             #-}",
        "{-# LANGUAGE ConstraintKinds            #-}",
        "{-# LANGUAGE DataKinds                  #-}",
        "{-# LANGUAGE DeriveFoldable             #-}",
        "{-# LANGUAGE DeriveFunctor              #-}",
        "{-# LANGUAGE DeriveGeneric              #-}",
        "{-# LANGUAGE DeriveTraversable          #-}",
        "{-# LANGUAGE FlexibleContexts           #-}",
        "{-# LANGUAGE FlexibleInstances          #-}",
        "{-# LANGUAGE GeneralizedNewtypeDeriving #-}",
        "{-# LANGUAGE InstanceSigs               #-}",
        "{-# LANGUAGE LambdaCase                 #-}",
        "{-# LANGUAGE MagicHash                  #-}",
        "{-# LANGUAGE MultiParamTypeClasses      #-}",
        "{-# LANGUAGE MultiWayIf                 #-}",
        "{-# LANGUAGE RankNTypes                 #-}",
        "{-# LANGUAGE RecordWildCards            #-}",
        "{-# LANGUAGE ScopedTypeVariables        #-}",
        "{-# LANGUAGE StandaloneDeriving         #-}",
        "{-# LANGUAGE TupleSections              #-}",
        "{-# LANGUAGE TypeApplications           #-}",
        "{-# LANGUAGE TypeFamilies               #-}",
        "{-# LANGUAGE TypeInType                 #-}",
        "{-# LANGUAGE TypeOperators              #-}",
        "{-# LANGUAGE UnboxedTuples              #-}",
        "{-# LANGUAGE UndecidableInstances       #-}",
        "-- pragmas.hs }}}",
        "module Main where",
        "",
        "import           Control.Monad            (replicateM_)",
        "import           Data.Array               (Array, (!))",
        "import qualified Data.ByteString          as BS",
        "import qualified Data.ByteString.Char8    as C",
        "import qualified Data.ByteString.Internal as BSI",
        "import qualified Data.IntMap              as IntMap",
        "import           Data.Ix                  (Ix)",
        "import           Debug.Trace              (trace)",
        "",
        "doCase :: IO ()",
        "doCase = do",
        "  return ()",
        "",
        "main :: IO ()",
        "main = getInt >>= flip replicateM_ doCase",
        "",
        "readInt :: C.ByteString -> Int",
        "readInt s = let Just (i,_) = C.readInt s in i :: Int",
        "",
        "readInt2 :: C.ByteString -> (Int, Int)",
        "readInt2 u = (a, b)",
        "  where",
        "  Just (a,v) = C.readInt u",
        "  Just (b,_) = C.readInt (C.tail v)",
        "",
        "readInts :: C.ByteString -> [Int]",
        "readInts str = readInt <$> BS.split (BSI.c2w ' ') str",
        "",
        "getInt :: IO Int",
        "getInt  = readInt <$> C.getLine",
        "",
        "getInt2 :: IO (Int, Int)",
        "getInt2 = readInt2 <$> C.getLine",
        "",
        "getInts :: IO [Int]",
        "getInts = readInts <$> C.getLine",
      },
    },
    lex = {
      t {
        "{-# LANGUAGE TupleSections #-}",
      },
    },
    bs = {
      c {
        t {
          "class Indexable f a where",
          "  atIdx :: f a -> Int -> a",
          "",
          "instance Indexable (Array Int) b where",
          "  atIdx :: Array Int a -> Int -> a",
          "  atIdx = (!)",
          "",
          "newtype Function a b = Function (a -> b)",
          "",
          "instance Indexable (Function Int) b where",
          "  atIdx :: Function Int b -> Int -> b",
          "  atIdx (Function f) = f",
          "",
          "instance Indexable IntMap.IntMap a where",
          "  atIdx :: IntMap.IntMap a -> Int -> a",
          "  atIdx = (IntMap.!)",
          "",
          "partitionPoint :: (Indexable f b) => Int -> Int -> (b -> Bool) -> f b -> Int",
          "-- range: [low, high)",
          "-- returns index of first element that doesn't satisfy predicate",
          "partitionPoint low' high' isCandidate range = bs low' high'",
          "  where",
          "  bs low high",
          "    | low == high = low",
          "    | isCandidate (atIdx range mid) = bs (mid + 1) high",
          "    | otherwise = bs low mid",
          "    where mid = (low + high) `div` 2",
          "",
          "lowerBound :: (Indexable f b, Ord b) => Int -> Int -> b -> f b -> Int",
          "lowerBound low high n = partitionPoint low high (<n)",
          "",
          "upperBound :: (Indexable f b, Ord b) => Int -> Int -> b -> f b -> Int",
          "upperBound low high n = partitionPoint low high (<=n)",
        },
        t {
          "class (Ix a) => Indexable f a b where",
          "  atIdx :: f a b -> a -> b",
          "",
          "instance Ix a => Indexable Array a b where",
          "  atIdx :: Ix a => Array a b -> a -> b",
          "  atIdx = (!)",
          "",
          "newtype Function a b = Function (a -> b)",
          "",
          "instance Ix a => Indexable Function a b where",
          "  atIdx :: Ix a => Function a b -> a -> b",
          "  atIdx (Function f) = f",
          "",
          "partitionPoint :: (Enum a, Indexable f a b) => a -> a -> (b -> Bool) -> f a b -> a",
          "-- range: [low, high)",
          "-- returns index of first element that doesn't satisfy predicate",
          "partitionPoint low' high' isCandidate range = bs low' high'",
          "  where",
          "  bs low high",
          "    | low == high = low",
          "    | isCandidate (atIdx range mid) = bs (next mid) high",
          "    | otherwise = bs low mid",
          "    where mid = toEnum $ (fromEnum low + fromEnum high) `div` 2",
          "  next x = toEnum $ fromEnum x + 1",
          "",
          "lowerBound :: (Enum a, Indexable f a b, Ord b) => a -> a -> b -> f a b -> a",
          "lowerBound low high n = partitionPoint low high (<n)",
          "",
          "upperBound :: (Enum a, Indexable f a b, Ord b) => a -> a -> b -> f a b -> a",
          "upperBound low high n = partitionPoint low high (<=n)",
        },
      },
    },
    dsu = {
      t {
        "data DSU = DSU (Int, Int) (IntMap.IntMap Int) (IntMap.IntMap Int) deriving Show",
        "",
        "dsuInit :: (Int, Int) -> DSU",
        "dsuInit bounds@(a, b) = DSU bounds parent size",
        "  where",
        "  parent = IntMap.fromList $ zip [a..b] [a..b]",
        "  size = IntMap.fromList $ zip [a..b] $ repeat 1",
        "",
        "dsuFind :: Int -> DSU -> (Int, DSU)",
        "dsuFind n' (DSU bounds' parent' size') = (ans, DSU bounds' newParent size')",
        "  where",
        "  (ans, newParent) = find n' parent'",
        "  find n parent",
        "    | p == n = (p, parent)",
        "    | otherwise = (root, finalParent)",
        "      where",
        "      (root, iParent) = find p parent",
        "      finalParent = IntMap.insert n root iParent",
        "      p = parent IntMap.! n",
        "",
        "dsuCombine :: Int -> Int -> DSU -> DSU",
        "dsuCombine x y dsu",
        "  | px == py = dsu2",
        "  | otherwise = DSU bounds newParent newSize",
        "  where",
        "  (px, dsu1) = dsuFind x dsu",
        "  (py, dsu2@(DSU bounds parent size)) = dsuFind y dsu1",
        "  sizePx = size IntMap.! px",
        "  sizePy = size IntMap.! py",
        "  newParent",
        "    | sizePx > sizePy = IntMap.insert py px parent",
        "    | otherwise = IntMap.insert px py parent",
        "  newSize",
        "    | sizePx > sizePy = IntMap.insert px (sizePx + sizePy) size",
        "    | otherwise = IntMap.insert py (sizePx + sizePy) size",
        "",
        "dsuEleSize :: Int -> DSU -> (Int, DSU)",
        "dsuEleSize n dsu = (size IntMap.! root, newDSU)",
        "  where",
        "  (root, newDSU@(DSU _ _ size)) = dsuFind n dsu",
        "",
        "dsuParents :: DSU -> ([Int], DSU)",
        "dsuParents dsu'@(DSU (low, high) _ _)= foldl dsuFold ([], dsu') [low..high]",
        "  where",
        "  dsuFold (xs, dsu) n = (root:xs, newDSU)",
        "    where",
        "    (root, newDSU) = dsuFind n dsu",
        "",
        "dsuSize :: DSU -> (Int, DSU)",
        "dsuSize dsu = (length $ group $ sort parents, newDSU)",
        "  where",
        "  (parents, newDSU) = dsuParents dsu",
      },
    },
  }
)
